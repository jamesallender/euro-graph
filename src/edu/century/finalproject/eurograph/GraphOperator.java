/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.century.finalproject.eurograph;

import java.util.Arrays;

import edu.century.finalproject.eurograph.collections.DestinationCollection;
import edu.century.finalproject.eurograph.collections.EuropeMap;
import edu.century.finalproject.eurograph.collections.IntList;
import edu.century.finalproject.eurograph.collections.IntStack;
import edu.century.finalproject.eurograph.collections.StationCollection;
import edu.century.finalproject.eurograph.exceptions.*;

/**
 *
 * @author Matt Divertie, Dan Young, and James Allender
 * 
 *         GraphOperator class for use in the project EuroRail for CSCI 2082
 *         Century College
 * 
 *         GraphOperator class is a top level class and contains the methods
 *         that operate on a graph
 */
public class GraphOperator {

	private static StationCollection graph;// An array list that will hold the
											// created Station objects
	private static IntStack itinerary; // A stack containing a possible route
	private static int distance[]; // Array to hold the distances generated by
									// dijkstra's algorithm
	private static int destenationCity; // The destination city for dijkstra's
										// algorithm
	private static int startCity; // The start city for dijkstra's algorithm

	/**
	 * Constructor creates a GraphOperator object witch creates a new stack and
	 * fills in the graph
	 */
	public GraphOperator() {

		itinerary = new IntStack();
		// Creates the graph of Europe from the hard coded data in EuropeMap
		graph = EuropeMap.fillStations();
	}

	/**
	 * gets the Destinations of a Station object.
	 * 
	 * @param stationName
	 *            a String that is the name of a city in the GraphOperator
	 * @return an array of the argument's Destinations
	 */
	public Destination[] getNeighbors(String stationName) {
		try {

			Station tmp;
			tmp = graph.search(stationName);
			return tmp.getNeighbors();
		} catch (StationNotFoundException e) {
			System.out.println(e.getMessage());
		}

		return null;
	}

	/**
	 * gets the Destinations that are contained the Station object with the
	 * vertexNumber equal to cityVertex
	 * 
	 * @param cityVertex
	 *            an int that refers to the vertexNumber of a city in the
	 *            GraphOperator
	 * @return an array of the Destinations in the Station with the vertexNumber
	 *         that is equal to cityVertex.
	 */
	public Destination[] getNeighbors(int cityVertex) {

		try {
			Station tmp;
			tmp = graph.search(cityVertex);
			return tmp.getNeighbors();
		} catch (StationNotFoundException e) {
			System.out.println(e.getMessage());
		}
		return null;
	}

	/**
	 * Returns a int array of the vertex values of cities connected to a given
	 * city vertex
	 * 
	 * @param cityVertex,
	 *            The vertex to get the neighbors of
	 * @return int array of the vertex values of cities connected to a given
	 *         city vertex
	 */
	public int[] getNeighborsVert(int cityVertex) {

		try {
			Station tmp;
			tmp = graph.search(cityVertex);
			return tmp.getNeighborsVert();
		} catch (StationNotFoundException e) {
			System.out.println(e.getMessage());
		}
		return null;
	}

	/**
	 * Checks if there is an edge between two vertices (cities) in the
	 * GraphOperator
	 * 
	 * @param from
	 *            a String that refers to the cityName from which the edge
	 *            should start.
	 * @param to
	 *            a String that refers to the cityName at which the edge will
	 *            end.
	 * @return true if there is an edge between 'from' and 'to', false if there
	 *         is not.
	 * @throws EmptyListException
	 * @throws StationNotFoundException
	 */
	public boolean isEdge(String from, String to) throws EmptyListException, StationNotFoundException {

		try {
			Station start = graph.search(from);

			DestinationCollection list = start.getDestinations();
			if (list.isEmpty()) {
				throw new EmptyListException();
			}

			return start.containsTarget(to);

		} catch (StationNotFoundException e) {
			throw new StationNotFoundException();
		}
	}

	/**
	 * Checks if there is an edge between two vertices (cities) in the
	 * GraphOperator
	 * 
	 * @param startVertex
	 *            an int that refers to the city's vertex from which the edge
	 *            should start.
	 * @param endVertex
	 *            a String that refers to the city's vertex at which the edge
	 *            will end.
	 * @return true if there is an edge between 'from' and 'to', false if there
	 *         is not.
	 * @throws EmptyListException
	 * @throws StationNotFoundException
	 */
	public static boolean isEdge(int startVertex, int endvertex) throws EmptyListException, StationNotFoundException {

		try {
			Station start = graph.search(startVertex);

			DestinationCollection list = start.getDestinations();
			if (list.isEmpty()) {
				throw new EmptyListException();
			}

			return start.containsTarget(endvertex);
		} catch (StationNotFoundException e) {
			throw new StationNotFoundException();
		}
	}

	/**
	 * gets the number of Destinations in a Station object
	 * 
	 * @param cityName
	 *            a String that refers to the Station whose Destinations you
	 *            wish to count
	 * @return an int that is the number of Destinations in the Station object
	 * @throws StationNotFoundException
	 */
	public int manyNeighbors(String cityName) throws StationNotFoundException {
		return graph.search(cityName).manyNeighbors();

	}

	/**
	 * gets the number of Destinations in a Station object
	 * 
	 * @param cityVertex
	 *            an int that refers to the Station whose Destinations you wish
	 *            to count
	 * @return an int that is the number of Destinations in the Station object
	 * @throws StationNotFoundException
	 */
	public int manyNeighbors(int cityVertex) throws StationNotFoundException {
		return graph.search(cityVertex).manyNeighbors();
	}

	/**
	 * gets the number of cities in the Graph
	 * 
	 * @return an int that is the number of cities in the Graph
	 */
	public int manyCities() {
		return graph.getSize();
	}

	/**
	 * gets a Station in the Graph
	 * 
	 * @param name
	 *            a String that refers to the cityName of the Station you wish
	 *            to get.
	 * @return a Station object with the cityName of name
	 * @throws StationNotFoundException
	 */
	public Station getStation(String name) throws StationNotFoundException {

		Station answer;

		answer = graph.search(name);

		return answer;
	}

	/**
	 * gets a Station from the GraphOperator object.
	 * 
	 * @param cityVertex
	 *            an int that refers to the vertexNumber of the Station you wish
	 *            to be returned.
	 * @return a Station object.
	 * @throws StationNotFoundException
	 */
	public static Station getStation(int cityVertex) throws StationNotFoundException {

		Station answer;

		answer = graph.search(cityVertex);

		return answer;
	}

	/**
	 * gets the vertexNumber of a city
	 * 
	 * @param cityName
	 *            a String that refers to the City object's cityName
	 * @return an int that is the vertexNumber of the City with the cityName of
	 *         the parameter cityName
	 * @throws StationNotFoundException
	 */
	public int getVertex(String cityName) throws StationNotFoundException {

		Station answer;

		answer = graph.search(cityName);

		return answer.getCityVertex();
	}

	/**
	 * Gets the amount of time it takes travel from one city to the other
	 * 
	 * @param from
	 *            The city traversing from
	 * @param to
	 *            The city traversing to
	 * @return The required time to travel
	 * @throws EmptyListException
	 * @throws StationNotFoundException
	 */
	public int getDistance(String from, String to) throws EmptyListException, StationNotFoundException {

		if (!isEdge(from, to))
			throw new StationNotFoundException();
		else {
			Station start = graph.search(from);

			return start.getDestination(to).getTimeWeight();
		}
	}

	/**
	 * Gets the amount of time it takes to travel between two cities
	 * 
	 * @param fromVert
	 *            The city traversing from
	 * @param toVert
	 *            The city traversing to
	 * @return The required time to travel
	 * @throws EmptyListException
	 * @throws StationNotFoundException
	 */
	public static int getDistance(int fromVert, int toVert) throws EmptyListException, StationNotFoundException {

		if (!isEdge(fromVert, toVert))
			throw new StationNotFoundException();
		else {
			Station stat = graph.search(fromVert);

			return stat.getDestination(toVert).getTimeWeight();
		}
	}

	/**
	 * A private method that gets the nearest neighbor vertex that is not in the
	 * allowed set of vertices.
	 *
	 * @param startVertex
	 *            The vertex from which Dijkstra's algorithm starts
	 * @param allowed
	 *            an IntList (LinkedList) that contains the set of allowed
	 *            vertices in the graph of graph
	 * @param distances
	 *            an array that contains the distances from the startVertex to
	 *            the vertex represented by the array position number
	 * @return an int that is the vertex number of the city that is closest to
	 *         the startVertex and not in the allowed set of vertices
	 * @throws EmptyListException
	 * @throws StationNotFoundException
	 */
	private int getNearest(int startVertex, IntList allowed, int[] distances)
			throws EmptyListException, StationNotFoundException {

		int nearest = startVertex;
		int trackedDist = Integer.MAX_VALUE;

		for (int i = 0; i < distances.length; i++) {

			if (!allowed.contains(i) && distances[i] < trackedDist) {
				nearest = i;
				trackedDist = distances[i];
			}
		}
		return nearest;
	}

	/**
	 * Performs Dijkstra's algorithm on a graph with a designated starting
	 * vertex. The method also pops the traversed vertices from the start vertex
	 * to the destination vertex into the graph's stack "itinerary"
	 * 
	 * This implementation of Dijkstra's algorithm is based on the description
	 * of the algorithm in Ch14 of 'Data Structures $ Other Objects Using Java'
	 * 4th edition by Michael Main
	 *
	 * @param map
	 *            a graph
	 * @param start
	 *            the vertex from which Dijkstra's will start
	 * @param dest
	 *            the vertex that is the destination of the trip. The method
	 *            will pop the vertices traversed to get to the destination into
	 *            the stack "itinerary"
	 * @return an array that contains the distances from the start vertex. The
	 *         position in the array refers to the vertex number, as opposed to
	 *         using a hash set.
	 * @throws StationNotFoundException
	 * @throws EmptyListException
	 */
	public static void dijkstra(GraphOperator map, int start, int dest)
			throws StationNotFoundException, EmptyListException, StationNotConnectedException {

		destenationCity = dest; // The destination city
		startCity = start; // The start city
		GraphOperator.getStation(start); // Map being operated on
		int numCities = map.manyCities(); // The number of cities in the map
		int sumDistince; // The total travel time to a vertex
		int currentVertex; // current vertex being checked
		int vertexOnPath;
		distance = new int[numCities]; // The node index corresponds to the
										// vertex num it holds the distance for
		int predecessor[] = new int[numCities];
		IntList allowedVertices = new IntList(); // Linked list of IntNodes

		// Sets all of the elements to Integer.MAX_VALUE to indicate they are
		// unvisited nodes
		Arrays.fill(distance, Integer.MAX_VALUE);

		distance[start] = 0;// Set distance to 0 at the initial node witch
		// corresponds to the [start] location in the
		// distance array

		//
		for (int allowedSize = 1; allowedSize < numCities; allowedSize++) {

			// 3.a
			// Assigns the next vertex to be checked
			currentVertex = map.getNearest(start, allowedVertices, distance);

			// 3.b Adds the current vertex to the set of allowed vertices
			allowedVertices.add(currentVertex);

			// 3.c This for loop is responsible for updating the distances
			// contained in the array named distance[]. For the currentVertex it
			// checks if every other vertex is already in the set of allowed
			// vertices. If check vertex is not in the allowed set, then the
			// loop checks if checkVertex is an immediate neighbor of current
			// vertex. If the distance from the start vertex to the current
			// vertex plus the distance between the current vertex and the
			// checkVertex is less than the current value in distance[] for
			// checkVertex, then distance[checkVertex] is updated to contain the
			// sum of the distance from the start vertex to the currentVertex
			// and
			// the distance between the currentVertex and the checkVertex.

			for (int checkVertex = 0; checkVertex < numCities; checkVertex++) {
				if ((!allowedVertices.contains(checkVertex)) && GraphOperator.isEdge(currentVertex, checkVertex)) {
					sumDistince = distance[currentVertex] + (getDistance(currentVertex, checkVertex));
					if (sumDistince < distance[checkVertex]) {
						distance[checkVertex] = sumDistince;
						// If the distance array was updated, then the int
						// variable in predecessor at the checkVertex'th
						// position is set to the value of currentVertex.
						predecessor[checkVertex] = currentVertex;
					}
					// If a path to the destination vertex exists, then
					// vertexOnPath gets the value of checkVertex. While
					// vertexOnPath is not the start vertex, vertexOnPath is
					// updated to the value contained in predecessor at the
					// vertexOnPath'th position. the value stored in
					// vertexOnPath is pushed into the itinerary Stack. If the
					// new value of vertexOnPath is not the start vertex, then
					// the loop repeats.

					if (distance[checkVertex] != Integer.MAX_VALUE && checkVertex == dest) {
						vertexOnPath = checkVertex;
						while (vertexOnPath != start) {
							vertexOnPath = predecessor[vertexOnPath];
							itinerary.push(vertexOnPath);
						}
					}
				}
			}
		}

		if (distance[dest] == Integer.MAX_VALUE)
			throw new StationNotConnectedException();

		map.checkRepeats(start);
	}

	/**
	 * Checks if there is more than one possible path in stack itinerary
	 *
	 * @param startCity
	 *            The city at which the the trip starts. The method checks if
	 *            this repeats, if it does, the remainder of the stack is
	 *            removed.
	 */
	public void checkRepeats(int startCity) {

		IntStack temp = new IntStack();

		temp.push(itinerary.pop());

		while (!itinerary.isEmpty()) {

			temp.push(itinerary.pop());

			if (!itinerary.isEmpty() && itinerary.peek() == startCity)
				itinerary.clear();
		}

		while (!temp.isEmpty())
			itinerary.push(temp.pop());

	}

	/**
	 * Gets the time required for the trip calculated by dijkstra's algorithm
	 * 
	 * @return The distance in hours
	 */
	public static int getTripTime() {
		return distance[destenationCity];
	}

	/**
	 * Gets the city name associated with a given vertex number
	 * 
	 * @param vertex
	 * @return the city name associated with a given vertex number
	 * @throws StationNotFoundException
	 */
	public String vertexCityName(int vertex) throws StationNotFoundException {

		return graph.search(vertex).getCityName();
	}

	/**
	 * Gets the city and country name associated with a given vertex number
	 * 
	 * @param vertex
	 * @return the city and country name associated with a given vertex number
	 * @throws StationNotFoundException
	 */
	public String getVertexCityAndCountryName(int vertex) throws StationNotFoundException {

		return graph.search(vertex).getCityAndCountry();
	}

	/**
	 * Creates a formated String of the optimal trip itinerary
	 * 
	 * @return A formated String containing trip itinerary
	 * @throws StationNotFoundException
	 * @throws EmptyListException
	 */
	public static String printItinerary() throws StationNotFoundException, EmptyListException {
		String trip = "";
		int k = 0;
		int index = -1;
		int next = startCity;
		int previous = -1;

		while (!itinerary.isEmpty()) {
			index = itinerary.pop();

			if (k == 0) {
				trip += "                    " + "Departing From: " + getStation(index).getCityAndCountry() + "\n";
				previous = next;

				k++;
			} else {
				trip += " From " + getStation(previous).getCityAndCountry() + " --To--> "
						+ getStation(index).getCityAndCountry() + ": " + getDistance(previous, index) + " Hours \n";
				previous = index;

			}
		}
		trip += " From " + getStation(previous).getCityAndCountry() + " --To--> "
				+ getStation(destenationCity).getCityAndCountry() + ": " + getDistance(index, destenationCity)
				+ " Hours \n";
		return trip;
	}

	/**
	 * Creates a String array where each element is a city and country, there is
	 * one element for each city
	 * 
	 * @return A String array of city country names
	 */
	public String[] getCitiesStringArr() {
		String cities[] = new String[getNumCities()];
		for (int i = 0; i < cities.length; i++) {
			try {
				cities[i] = getVertexCityAndCountryName(i);
			} catch (StationNotFoundException e) {
				e.printStackTrace();
			}
		}
		return cities;
	}

	/**
	 * Gets the total number of cities in the graph
	 * 
	 * @return The size of the graph
	 */
	public int getNumCities() {
		return graph.getSize();
	}

	/**
	 * Gets the vertex value for a city country coupled String
	 * 
	 * @param cityCountryName
	 *            The city and country combination name to be operated on
	 * @return an int corresponding to the given city country name
	 * @throws StationNotFoundException
	 */
	public static int guiSelectionInterpriter(String cityCountryName) throws StationNotFoundException {
		String[] split = cityCountryName.split(",");
		return graph.search(split[0]).getCityVertex();
	}

	/**
	 * Breaks apart a coupled city and country name and returns just the cities
	 * name
	 * 
	 * @param cityCountryName
	 *            The city and country combination name to be operated on
	 * @return A String containing the name of the city from the passed city
	 *         country combo
	 * @throws StationNotFoundException
	 */
	public static String guiSelectionInterpriterGiveCity(String cityCountryName) throws StationNotFoundException {
		String[] split = cityCountryName.split(",");
		return split[0];

	}

	/**
	 * Gets the Graph being used
	 * 
	 * @return the graph
	 */
	public static StationCollection getGraph() {
		return graph;
	}

	/**
	 * Sets the graph being used
	 * 
	 * @param graph
	 *            the graph to set
	 */
	public static void setGraph(StationCollection graph) {
		GraphOperator.graph = graph;
	}

	/**
	 * Gets the trip itinerary
	 * 
	 * @return the itinerary
	 */
	public static IntStack getItinerary() {
		return itinerary;
	}

	/**
	 * Sets the trip itinerary
	 * 
	 * @param itinerary
	 *            the itinerary to set
	 */
	public static void setItinerary(IntStack itinerary) {
		GraphOperator.itinerary = itinerary;
	}

	/**
	 * Gets the Distance array
	 * 
	 * @return the distance
	 */
	public static int[] getDistance() {
		return distance;
	}

	/**
	 * Sets the Distance array
	 * 
	 * @param distance
	 *            the distance to set
	 */
	public static void setDistance(int[] distance) {
		GraphOperator.distance = distance;
	}

	/**
	 * Gets the destination city
	 * 
	 * @return the destenationCity
	 */
	public static int getDestinationCity() {
		return destenationCity;
	}

	/**
	 * Sets the destination city
	 * 
	 * @param destenationCity
	 *            the destenationCity to set
	 */
	public static void setDestenationCity(int destenationCity) {
		GraphOperator.destenationCity = destenationCity;
	}

	/**
	 * Gets the start city
	 * 
	 * @return the startCity
	 */
	public static int getStartCity() {
		return startCity;
	}

	/**
	 * Sets the start city
	 * 
	 * @param startCity
	 *            the startCity to set
	 */
	public static void setStartCity(int startCity) {
		GraphOperator.startCity = startCity;
	}

}
